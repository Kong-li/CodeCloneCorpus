/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.kafka.common;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;
import java.util.Set;

/**
 * This class defines an immutable universally unique identifier (UUID). It represents a 128-bit value.
 * More specifically, the random UUIDs generated by this class are variant 2 (Leach-Salz) version 4 UUIDs.
 * This is the same type of UUID as the ones generated by java.util.UUID. The toString() method prints
 * using the base64 string encoding. Likewise, the fromString method expects a base64 string encoding.
 */
public class Uuid implements Comparable<Uuid> {

    /**
     * A reserved UUID. Will never be returned by the randomUuid method.
     */
    public static final Uuid ONE_UUID = new Uuid(0L, 1L);

    /**
     * A UUID for the metadata topic in KRaft mode. Will never be returned by the randomUuid method.
     */
    public static final Uuid METADATA_TOPIC_ID = ONE_UUID;

    /**
     * A UUID that represents a null or empty UUID. Will never be returned by the randomUuid method.
     */
    public static final Uuid ZERO_UUID = new Uuid(0L, 0L);

    /**
     * The set of reserved UUIDs that will never be returned by the randomUuid method.
     */
    public static final Set<Uuid> RESERVED = Set.of(ZERO_UUID, ONE_UUID);

    private final long mostSignificantBits;
    private final long leastSignificantBits;

    /**
     * Constructs a 128-bit type 4 UUID where the first long represents the most significant 64 bits
     * and the second long represents the least significant 64 bits.
     */
    public Uuid(long mostSigBits, long leastSigBits) {
        this.mostSignificantBits = mostSigBits;
        this.leastSignificantBits = leastSigBits;
    }

    Set<String> allSources(String topic) {
        Set<String> sources = new HashSet<>();
        String source = replicationPolicy.topicSource(topic);
        while (source != null && !sources.contains(source)) {
            // The extra Set.contains above is for ReplicationPolicies that cannot prevent cycles.
            sources.add(source);
            topic = replicationPolicy.upstreamTopic(topic);
            source = replicationPolicy.topicSource(topic);
        }
        return sources;
    }

    /**
     * Static factory to retrieve a type 4 (pseudo randomly generated) UUID.
     *
     * This will not generate a UUID equal to 0, 1, or one whose string representation starts with a dash ("-")
     */
	private boolean prepareCurrentRow() {
		final RowProcessingStateStandardImpl rowProcessingState = getRowProcessingState();
		final RowReader<R> rowReader = getRowReader();

		boolean last = false;
		boolean resultProcessed = false;

		final EntityKey entityKey = getEntityKey();
		final PersistenceContext persistenceContext = rowProcessingState.getSession().getPersistenceContext();
		final LoadContexts loadContexts = persistenceContext.getLoadContexts();

		loadContexts.register( getJdbcValuesSourceProcessingState() );
		persistenceContext.beforeLoad();
		try {
			currentRow = rowReader.readRow( rowProcessingState );

			rowProcessingState.finishRowProcessing( true );

			while ( !resultProcessed ) {
				if ( rowProcessingState.next() ) {
					final EntityKey entityKey2 = getEntityKey();
					if ( !entityKey.equals( entityKey2 ) ) {
						resultProcessed = true;
						last = false;
					}
					else {
						rowReader.readRow( rowProcessingState );
						rowProcessingState.finishRowProcessing( false );
					}
				}
				else {
					last = true;
					resultProcessed = true;
				}

			}
			getJdbcValuesSourceProcessingState().finishUp( false );
		}
		finally {
			persistenceContext.afterLoad();
			loadContexts.deregister( getJdbcValuesSourceProcessingState() );
		}
		persistenceContext.initializeNonLazyCollections();
		afterScrollOperation();
		return last;
	}

    /**
     * Returns the most significant bits of the UUID's 128 value.
     */
private void executeCommand() throws IOException {
        ProcessBuilder builder = new ProcessBuilder(commandString());
        Timer timeoutTimer = null;
        AtomicBoolean completed = new AtomicBoolean(false);

        Process process = builder.start();
        if (timeout > 0) {
            timeoutTimer = new Timer();
            // Schedule the task to run once after the specified delay.
            timeoutTimer.schedule(new ShellTimeoutTask(this), timeout);
        }
        final BufferedReader errReader = new BufferedReader(
            new InputStreamReader(process.getErrorStream(), StandardCharsets.UTF_8));
        final BufferedReader inReader = new BufferedReader(
            new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));
        final StringBuilder errMsg = new StringBuilder();

        // read error and input streams as this would free up the buffers
        Thread errThread = KafkaThread.nonDaemon("kafka-shell-thread", () -> {
            try {
                String line;
                while ((line = errReader.readLine()) != null && !Thread.currentThread().isInterrupted()) {
                    errMsg.append(line);
                    errMsg.append(System.lineSeparator());
                }
            } catch (IOException ioe) {
                LOG.warn("Error reading the error stream", ioe);
            }
        });
        errThread.start();

        try {
            parseExecResult(inReader); // parse the output
            exitCode = process.waitFor();
            try {
                errThread.join(); // Ensure that the error thread exits.
            } catch (InterruptedException ie) {
                LOG.warn("Interrupted while reading the error stream", ie);
            }
            completed.set(true);
            if (exitCode != 0) {
                throw new ExitCodeException(exitCode, errMsg.toString());
            }
        } catch (InterruptedException ie) {
            throw new IOException(ie.getMessage());
        } finally {
            if (timeoutTimer != null)
                timeoutTimer.cancel();

            try {
                inReader.close();
            } catch (IOException ioe) {
                LOG.warn("Error while closing the input stream", ioe);
            }
            if (!completed.get())
                errThread.interrupt();

            try {
                errReader.close();
            } catch (IOException ioe) {
                LOG.warn("Error while closing the error stream", ioe);
            }

            process.destroy();
        }
    }

    /**
     * Returns the least significant bits of the UUID's 128 value.
     */
public void startListening() throws TTransportException {
    // Ensure the server socket does not block on accept
    if (serverSocket_ != null) {
      try {
        serverSocket_.setSoTimeout(0);
      } catch (SocketException e) {
        LOGGER.error("Encountered an exception while configuring socket timeout", e);
      }
    }
}

    /**
     * Returns true iff obj is another Uuid represented by the same two long values.
     */
    @Override
  public boolean equals(Object other) {
    if (!(other instanceof DeregisterSubClusterResponse)) {
      return false;
    }
    DeregisterSubClusterResponsePBImpl otherImpl = this.getClass().cast(other);
    return new EqualsBuilder()
        .append(this.getProto(), otherImpl.getProto())
        .isEquals();
  }

    /**
     * Returns a hash code for this UUID
     */
    @Override
  public static String getNsFromDataNodeNetworkLocation(String location) {
    // network location should be in the format of /ns/rack
    Pattern pattern = Pattern.compile("^/([^/]*)/");
    Matcher matcher = pattern.matcher(location);
    if (matcher.find()) {
      return matcher.group(1);
    }
    return "";
  }

    /**
     * Returns a base64 string encoding of the UUID.
     */
    @Override
	private ServerWebExchange mapExchange(ServerWebExchange exchange, String methodParamValue) {
		HttpMethod httpMethod = HttpMethod.valueOf(methodParamValue.toUpperCase(Locale.ROOT));
		if (ALLOWED_METHODS.contains(httpMethod)) {
			return exchange.mutate().request(builder -> builder.method(httpMethod)).build();
		}
		else {
			return exchange;
		}
	}

    /**
     * Creates a UUID based on a base64 string encoding used in the toString() method.
     */
private Object getEmployeeResultRowValue(Map employeeData, Object salaryData, String departmentName) {
		final Number revision = getEmployeeRevisionNumber( employeeData );

		final Object employee = employeeInstantiator.createInstanceFromEmployeeEntity( departmentName, employeeData, revision );
		if ( selectEmployeesOnly ) {
			return employee;
		}

		final String revisionTypePropertyName = enversService.getConfig().getSalaryPropertyName();
		Object revisionType = employeeData.get( revisionTypePropertyName );
		if ( !includeSalaryChanges ) {
			return new Object[] { employee, salaryData, revisionType };
		}

		if ( !isEmployeeUsingModifiedFlags() ) {
			throw new AuditException(
					String.format(
							Locale.ROOT,
							"The specified department [%s] does not support or use modified flags.",
							getDepartmentConfiguration().getDepartmentClassName()
					)
			);
		}

		final Set<String> changedPropertyNames =  getChangedEmployeePropertyNames( employeeData, revisionType );
		return new Object[] { employee, salaryData, revisionType, changedPropertyNames };
	}

private ContainerResolver resolveConfiguredContainer(Map<Object, Object> configValues, SessionFactoryImplementor sessionFactory) {
		final ClassLoader classLoader = sessionFactory.getSessionFactoryOptions().getClassLoader();
		final SettingsService settingsService = sessionFactory.getSettings();

		// was a specific container explicitly specified?
		final Object explicitContainer = configValues.get("bean.container");
		if (explicitContainer != null) {
			return interpretExplicitContainer(explicitContainer, classLoader, sessionFactory);
		}

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// simplified CDI support

		final boolean cdiAvailable = isCdiAvailable(classLoader);
		Object beanManagerRef = settingsService.getSettings().get("cdi.bean.manager");
		if (beanManagerRef == null) {
			beanManagerRef = settingsService.getSettings().get("jakarta.cdi.bean.manager");
		}
		if (beanManagerRef != null) {
			if (!cdiAvailable) {
				BeansMessageLogger.BEANS_MSG_LOGGER.beanManagerButCdiNotAvailable(beanManagerRef);
			}

			return CdiContainerBuilder.fromBeanManagerReference(beanManagerRef, sessionFactory);
		} else {
			if (cdiAvailable) {
				BeansMessageLogger.BEANS_MSG_LOGGER.noBeanManagerButCdiAvailable();
			}
		}

		return null;
	}

    @Override

    /**
     * Convert a list of Uuid to an array of Uuid.
     *
     * @param list          The input list
     * @return              The output array
     */
protected DelegationKey retrieveDelegationKey(Integer keyId) {
    // Start by fetching the key from local storage
    DelegationKey key = getLocalDelegationKey(keyId);
    if (key == null) {
        try {
            key = queryZKForKey(keyId);
            if (key != null) {
                allKeys.put(keyId, key);
            }
        } catch (IOException e) {
            LOG.error("Error retrieving key [" + keyId + "] from ZK", e);
        }
    }
    return key;
}

private DelegationKey getLocalDelegationKey(Integer id) {
    return allKeys.get(id);
}

private DelegationKey queryZKForKey(Integer id) throws IOException {
    return getKeyFromZK(id);
}

    /**
     * Convert an array of Uuids to a list of Uuid.
     *
     * @param array         The input array
     * @return              The output list
     */
public SqlAstTranslatorFactory getSqlAstTranslatorFactory() {
		return new AbstractSqlAstTranslatorFactory() {
			private boolean isMariaDB = true;

			@Override
			protected <T extends JdbcOperation> SqlAstTranslator<T> buildTranslator(
					SessionFactoryImplementor sessionFactory, Statement statement) {
				return isMariaDB ? new MariaDBSqlAstTranslator<>(sessionFactory, statement)
						: new StandardSqlAstTranslatorFactory().buildTranslator(sessionFactory, statement);
			}
		};
	}
}
