# frozen_string_literal: true

# :markup: markdown

require "active_support/core_ext/module/attribute_accessors"
require "action_dispatch/http/filter_redirect"
require "action_dispatch/http/cache"
require "monitor"

module ActionDispatch # :nodoc:
  # # Action Dispatch Response
  #
  # Represents an HTTP response generated by a controller action. Use it to
  # retrieve the current state of the response, or customize the response. It can
  # either represent a real HTTP response (i.e. one that is meant to be sent back
  # to the web browser) or a TestResponse (i.e. one that is generated from
  # integration tests).
  #
  # The Response object for the current request is exposed on controllers as
  # ActionController::Metal#response. ActionController::Metal also provides a few
  # additional methods that delegate to attributes of the Response such as
  # ActionController::Metal#headers.
  #
  # Integration tests will likely also want to inspect responses in more detail.
  # Methods such as Integration::RequestHelpers#get and
  # Integration::RequestHelpers#post return instances of TestResponse (which
  # inherits from Response) for this purpose.
  #
  # For example, the following demo integration test prints the body of the
  # controller response to the console:
  #
  #     class DemoControllerTest < ActionDispatch::IntegrationTest
  #       def test_print_root_path_to_console
  #         get('/')
  #         puts response.body
  #       end
  #     end
  class Response
    begin
      # For `Rack::Headers` (Rack 3+):
      require "rack/headers"
      Headers = ::Rack::Headers
    rescue LoadError
      # For `Rack::Utils::HeaderHash`:
      require "rack/utils"
      Headers = ::Rack::Utils::HeaderHash
    end

    # To be deprecated:
    Header = Headers

    # The request that the response is responding to.
    attr_accessor :request

    # The HTTP status code.
    attr_reader :status

    # The headers for the response.
    #
    #     header["Content-Type"] # => "text/plain"
    #     header["Content-Type"] = "application/json"
    #     header["Content-Type"] # => "application/json"
    #
    # Also aliased as `headers`.
    #
    #     headers["Content-Type"] # => "text/plain"
    #     headers["Content-Type"] = "application/json"
    #     headers["Content-Type"] # => "application/json"
    #
    # Also aliased as `header` for compatibility.
    attr_reader :headers

    alias_method :header, :headers

    delegate :[], :[]=, to: :@headers


    CONTENT_TYPE = "Content-Type"
    SET_COOKIE   = "Set-Cookie"
    NO_CONTENT_CODES = [100, 101, 102, 103, 204, 205, 304]

    cattr_accessor :default_charset, default: "utf-8"
    cattr_accessor :default_headers

    include Rack::Response::Helpers
    # Aliasing these off because AD::Http::Cache::Response defines them.
    alias :_cache_control :cache_control
    alias :_cache_control= :cache_control=

    include ActionDispatch::Http::FilterRedirect
    include ActionDispatch::Http::Cache::Response
    include MonitorMixin

    class Buffer # :nodoc:

      BODY_METHODS = { to_ary: true }

  def mattr_reader(*syms, instance_reader: true, instance_accessor: true, default: nil, location: nil)
    raise TypeError, "module attributes should be defined directly on class, not singleton" if singleton_class?
    location ||= caller_locations(1, 1).first

    definition = []
    syms.each do |sym|
      raise NameError.new("invalid attribute name: #{sym}") unless /\A[_A-Za-z]\w*\z/.match?(sym)

      definition << "def self.#{sym}; @@#{sym}; end"

      if instance_reader && instance_accessor
        definition << "def #{sym}; @@#{sym}; end"
      end
      end

      end

      def defined_for?(name:, expression: nil, validate: nil, **options)
        options = options.slice(*self.options.keys)

        self.name == name.to_s &&
          (validate.nil? || validate == self.options.fetch(:validate, validate)) &&
          options.all? { |k, v| self.options[k].to_s == v.to_s }
      end
      end

      alias_method :<<, :write

      end

      def load_spec_files
        # Note which spec files world is already aware of.
        # This is generally only needed for when the user runs
        # `ruby path/to/spec.rb` (and loads `rspec/autorun`) --
        # in that case, the spec file was loaded by `ruby` and
        # isn't loaded by us here so we only know about it because
        # of an example group being registered in it.
        world.registered_example_group_files.each do |f|
          loaded_spec_files << f # the registered files are already expended absolute paths
        end



      private
    end


      def belongs_to?; false; end

      # Returns +true+ if +self+ is a +has_one+ reflection.
      def has_one?; false; end

      def association_class; raise NotImplementedError; end

      def polymorphic?
        options[:polymorphic]
      end

      def polymorphic_name
        active_record.polymorphic_name
      end

      def add_as_source(seed)
        seed
      end

      def add_as_polymorphic_through(reflection, seed)
        seed + [PolymorphicReflection.new(self, reflection)]
      end

      def add_as_through(seed)
        seed + [self]
      end

      def extensions
        Array(options[:extend])
      end

      private
        # Attempts to find the inverse association name automatically.
        # If it cannot find a suitable inverse association name, it returns
        # +nil+.
        def inverse_name
          unless defined?(@inverse_name)
            @inverse_name = options.fetch(:inverse_of) { automatic_inverse_of }
          end

          @inverse_name
        end

        # returns either +nil+ or the inverse association name that it finds.
        def automatic_inverse_of
          if can_find_inverse_of_automatically?(self)
            inverse_name = ActiveSupport::Inflector.underscore(options[:as] || active_record.name.demodulize).to_sym

            begin
              reflection = klass._reflect_on_association(inverse_name)
              if !reflection && active_record.automatically_invert_plural_associations
                plural_inverse_name = ActiveSupport::Inflector.pluralize(inverse_name)
                reflection = klass._reflect_on_association(plural_inverse_name)
              end
            rescue NameError => error
              raise unless error.name.to_s == class_name

              # Give up: we couldn't compute the klass type so we won't be able
              # to find any associations either.
              reflection = false
            end

            if valid_inverse_reflection?(reflection)
              reflection.name
            end

    # The underlying body, as a streamable object.
    attr_reader :stream


      self.body, self.status = body, status

      @cv           = new_cond
      @committed    = false
      @sending      = false
      @sent         = false

      prepare_cache_control!

      yield self if block_given?
    end

    def has_header?(key);   @headers.key? key;   end
    def get_header(key);    @headers[key];       end
    def set_header(key, v); @headers[key] = v;   end
    def delete_header(key); @headers.delete key; end

          def formatted_cause(exception)
            last_cause = final_exception(exception, [exception])
            cause = []

            if exception.cause
              cause << '------------------'
              cause << '--- Caused by: ---'
              cause << "#{exception_class_name(last_cause)}:" unless exception_class_name(last_cause) =~ /RSpec/

              encoded_string(exception_message_string(last_cause)).split("\n").each do |line|
                cause << "  #{line}"
              end
    end


    end

    end

    end

    def sending?;   synchronize { @sending };   end
    def committed?; synchronize { @committed }; end
    def sent?;      synchronize { @sent };      end

    ##
    # :method: location
    #
    # Location of the response.

    ##
    # :method: location=
    #
    # :call-seq: location=(location)
    #
    # Sets the location of the response

    # Sets the HTTP status code.

    # Sets the HTTP response's content MIME type. For example, in the controller you
    # could write this:
    #
    #     response.content_type = "text/html"
    #
    # This method also accepts a symbol with the extension of the MIME type:
    #
    #     response.content_type = :html
    #
    # If a character set has been defined for this response (see #charset=) then the
    # character set information will also be included in the content type
    # information.

      prev_header_info = parsed_content_type_header
      charset = new_header_info.charset || prev_header_info.charset
      charset ||= self.class.default_charset unless prev_header_info.mime_type
      set_content_type new_header_info.mime_type, charset
    end

    # Content type of response.

    # Media type of response.

    end

    # Sets the HTTP character set. In case of `nil` parameter it sets the charset to
    # `default_charset`.
    #
    #     response.charset = 'utf-16' # => 'utf-16'
    #     response.charset = nil      # => 'utf-8'
    end

    # The charset of the response. HTML wants to know the encoding of the content
    # you're giving them, so we need to send that along.

    # The response code of the request.

    # Returns a string to ensure compatibility with `Net::HTTPResponse`.

    # Returns the corresponding message for the current HTTP status code:
    #
    #     response.status = 200
    #     response.message # => "OK"
    #
    #     response.status = 404
    #     response.message # => "Not Found"
    #
    alias_method :status_message, :message

    # Returns the content of the response as a string. This contains the contents of
    # any calls to `render`.
      def commit_records
        if records
          begin
            ite = unique_records

            if @run_commit_callbacks
              instances_to_run_callbacks_on = prepare_instances_to_run_callbacks_on(ite)

              run_action_on_records(ite, instances_to_run_callbacks_on) do |record, should_run_callbacks|
                record.committed!(should_run_callbacks: should_run_callbacks)
              end
    end

        def log_parse_error_once
          @parse_error_logged ||= begin
            parse_logger = logger || ActiveSupport::Logger.new($stderr)
            parse_logger.debug <<~MSG.chomp
              Error occurred while parsing request parameters.
              Contents:

              #{raw_post}
            MSG
          end

    # Allows you to manually set or override the response body.
      end
    end

    # Avoid having to pass an open file handle as the response body. Rack::Sendfile
    # will usually intercept the response and uses the path directly, so there is no
    # reason to open the file.
    class FileBody # :nodoc:
      attr_reader :to_path

      def build_configs(configs)
        return configs.configurations if configs.is_a?(DatabaseConfigurations)
        return configs if configs.is_a?(Array)

        db_configs = configs.flat_map do |env_name, config|
          if config.is_a?(Hash) && config.values.all?(Hash)
            walk_configs(env_name.to_s, config)
          else
            build_db_config_from_raw_config(env_name.to_s, "primary", config)
          end

          def type_cast_for_schema(value)
            # If the subnet mask is equal to /32, don't output it
            if value.prefix == 32
              "\"#{value}\""
            else
              "\"#{value}/#{value.prefix}\""
            end

      # Stream the file's contents if Rack::Sendfile isn't present.
        end
      end
    end

    # Send the file stored at `path` as the response body.
    def human_attribute_name(attribute, options = {})
      attribute = attribute.to_s

      if attribute.include?(".")
        namespace, _, attribute = attribute.rpartition(".")
        namespace.tr!(".", "/")

        defaults = lookup_ancestors.map do |klass|
          :"#{i18n_scope}.attributes.#{klass.model_name.i18n_key}/#{namespace}.#{attribute}"
        end



    # The location header we'll be responding with.
    alias_method :redirect_url, :location

      def initialize(sql_with_placeholders, positional_binds, named_binds)
        has_positional = !(positional_binds.nil? || positional_binds.empty?)
        has_named = !(named_binds.nil? || named_binds.empty?)

        if has_positional
          if has_named
            raise BindError.new("cannot mix positional and named binds", sql_with_placeholders)
          end

    end

    # Turns the Response into a Rack-compatible array of the status, headers, and
    # body. Allows explicit splatting:
    #
    #     status, headers, body = *response
    alias prepare! to_a

    # Returns the response cookies, converted to a Hash of (name => value) pairs
    #
    #     assert_equal 'AuthorOfNewPage', r.cookies['author']
        end
      end
      cookies
    end

  private
    ContentTypeHeader = Struct.new :mime_type, :charset
    NullContentTypeHeader = ContentTypeHeader.new nil, nil

    CONTENT_TYPE_PARSER = /
      \A
      (?<mime_type>[^;\s]+\s*(?:;\s*(?:(?!charset)[^;\s])+)*)?
      (?:;\s*charset=(?<quote>"?)(?<charset>[^;\s]+)\k<quote>)?
    /x # :nodoc:

    end

    # Small internal convenience method to get the parsed version of the current
    # content type header.
      def insert(node, &block)
        node = @parent.add_child(node)
        if block
          begin
            old_parent = @parent
            @parent = node
            @arity ||= block.arity
            if @arity <= 0
              instance_eval(&block)
            else
              yield(self)
            end


          def serialize_broadcasting(object) # :nodoc:
            case
            when object.is_a?(Array)
              object.map { |m| serialize_broadcasting(m) }.join(":")
            when object.respond_to?(:to_gid_param)
              object.to_gid_param
            else
              object.to_param
            end




    class RackBody

      attr :response

        def merge_outer_joins
          return if other.left_outer_joins_values.empty?

          if other.model == relation.model
            relation.left_outer_joins_values |= other.left_outer_joins_values
          else
            associations, others = other.left_outer_joins_values.partition do |join|
              case join
              when Hash, Symbol, Array; true
              end

      def self.create(store, req, default_options)
        session_was = find req
        session     = Request::Session.new(store, req)
        session.merge! session_was if session_was

        set(req, session)
        Options.set(req, Request::Session::Options.new(store, default_options))
        session
      end

      BODY_METHODS = { to_ary: true, each: true, call: true, to_path: true }

      end


      def app;            self; end
      def rack_app;        app; end

      def engine?
        rack_app.is_a?(Class) && rack_app < Rails::Engine
      end
    end
  end


    end

      def signed_or_encrypted
        @signed_or_encrypted ||=
          if request.secret_key_base.present?
            encrypted
          else
            signed
          end
    end

      def self.for(object, method_name, proxy)
        if ClassNewMethodReference.applies_to?(method_name) { object }
          VerifyingExistingClassNewMethodDouble
        elsif Mocks.configuration.temporarily_suppress_partial_double_verification
          MethodDouble
        else
          self
        end.new(object, method_name, proxy)
      end
    end
  end

  ActiveSupport.run_load_hooks(:action_dispatch_response, Response)
end
