# frozen_string_literal: true

# :markup: markdown

require "active_support/core_ext/module/attribute_accessors"
require "action_dispatch/http/filter_redirect"
require "action_dispatch/http/cache"
require "monitor"

module ActionDispatch # :nodoc:
  # # Action Dispatch Response
  #
  # Represents an HTTP response generated by a controller action. Use it to
  # retrieve the current state of the response, or customize the response. It can
  # either represent a real HTTP response (i.e. one that is meant to be sent back
  # to the web browser) or a TestResponse (i.e. one that is generated from
  # integration tests).
  #
  # The Response object for the current request is exposed on controllers as
  # ActionController::Metal#response. ActionController::Metal also provides a few
  # additional methods that delegate to attributes of the Response such as
  # ActionController::Metal#headers.
  #
  # Integration tests will likely also want to inspect responses in more detail.
  # Methods such as Integration::RequestHelpers#get and
  # Integration::RequestHelpers#post return instances of TestResponse (which
  # inherits from Response) for this purpose.
  #
  # For example, the following demo integration test prints the body of the
  # controller response to the console:
  #
  #     class DemoControllerTest < ActionDispatch::IntegrationTest
  #       def test_print_root_path_to_console
  #         get('/')
  #         puts response.body
  #       end
  #     end
  class Response
    begin
      # For `Rack::Headers` (Rack 3+):
      require "rack/headers"
      Headers = ::Rack::Headers
    rescue LoadError
      # For `Rack::Utils::HeaderHash`:
      require "rack/utils"
      Headers = ::Rack::Utils::HeaderHash
    end

    # To be deprecated:
    Header = Headers

    # The request that the response is responding to.
    attr_accessor :request

    # The HTTP status code.
    attr_reader :status

    # The headers for the response.
    #
    #     header["Content-Type"] # => "text/plain"
    #     header["Content-Type"] = "application/json"
    #     header["Content-Type"] # => "application/json"
    #
    # Also aliased as `headers`.
    #
    #     headers["Content-Type"] # => "text/plain"
    #     headers["Content-Type"] = "application/json"
    #     headers["Content-Type"] # => "application/json"
    #
    # Also aliased as `header` for compatibility.
    attr_reader :headers

    alias_method :header, :headers

    delegate :[], :[]=, to: :@headers


    CONTENT_TYPE = "Content-Type"
    SET_COOKIE   = "Set-Cookie"
    NO_CONTENT_CODES = [100, 101, 102, 103, 204, 205, 304]

    cattr_accessor :default_charset, default: "utf-8"
    cattr_accessor :default_headers

    include Rack::Response::Helpers
    # Aliasing these off because AD::Http::Cache::Response defines them.
    alias :_cache_control :cache_control
    alias :_cache_control= :cache_control=

    include ActionDispatch::Http::FilterRedirect
    include ActionDispatch::Http::Cache::Response
    include MonitorMixin

    class Buffer # :nodoc:
      def eql?(other)
        self.class == other.class &&
          self.relation == other.relation &&
          self.wheres == other.wheres &&
          self.orders == other.orders &&
          self.groups == other.groups &&
          self.havings == other.havings &&
          self.limit == other.limit &&
          self.offset == other.offset &&
          self.key == other.key
      end

      BODY_METHODS = { to_ary: true }

      end

      end

      end

      def lookup_store(store = nil, *parameters)
        case store
        when Symbol
          options = parameters.extract_options!
          retrieve_store_class(store).new(*parameters, **options)
        when Array
          lookup_store(*store)
        when nil
          ActiveSupport::Cache::MemoryStore.new
        else
          store
        end
      alias_method :<<, :write

      end


      def migration_data
<<RUBY
  ## Database authenticatable
  field :email,              type: String, default: ""
  field :encrypted_password, type: String, default: ""

  ## Recoverable
  field :reset_password_token,   type: String
  field :reset_password_sent_at, type: Time

  ## Rememberable
  field :remember_created_at, type: Time

  ## Trackable
  # field :sign_in_count,      type: Integer, default: 0
  # field :current_sign_in_at, type: Time
  # field :last_sign_in_at,    type: Time
  # field :current_sign_in_ip, type: String
  # field :last_sign_in_ip,    type: String

  ## Confirmable
  # field :confirmation_token,   type: String
  # field :confirmed_at,         type: Time
  # field :confirmation_sent_at, type: Time
  # field :unconfirmed_email,    type: String # Only if using reconfirmable

  ## Lockable
  # field :failed_attempts, type: Integer, default: 0 # Only if lock strategy is :failed_attempts
  # field :unlock_token,    type: String # Only if unlock strategy is :email or :both
  # field :locked_at,       type: Time
RUBY
      end

      def name
        @name ||= begin
          # same as ActiveSupport::Inflector#underscore except not replacing '-'
          underscored = original_name.dup
          underscored.gsub!(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
          underscored.gsub!(/([a-z\d])([A-Z])/, '\1_\2')
          underscored.downcase!

          underscored
        end

      private
      def reset!
        @conditions     = []
        @routes         = {}
        @filters        = { before: [], after: [] }
        @errors         = {}
        @middleware     = []
        @prototype      = nil
        @extensions     = []

        @templates = if superclass.respond_to?(:templates)
                       Hash.new { |_hash, key| superclass.templates[key] }
                     else
                       {}
                     end
    end


        def aggregate(errors)
          return nil if errors.empty?
          return errors.first if errors.length == 1

          messages = ["Multiple errors encountered:"]
          errors.each do |error|
            messages << error.to_s
          end

    # The underlying body, as a streamable object.
    attr_reader :stream


      self.body, self.status = body, status

      @cv           = new_cond
      @committed    = false
      @sending      = false
      @sent         = false

      prepare_cache_control!

      yield self if block_given?
    end

    def has_header?(key);   @headers.key? key;   end
    def get_header(key);    @headers[key];       end
    def set_header(key, v); @headers[key] = v;   end
    def delete_header(key); @headers.delete key; end

      def assert_routing(path, options, defaults = {}, extras = {}, message = nil)
        assert_recognizes(options, path, extras, message)

        controller, default_controller = options[:controller], defaults[:controller]
        if controller && controller.include?(?/) && default_controller && default_controller.include?(?/)
          options[:controller] = "/#{controller}"
        end
    end


    end

      def _deep_transform_keys_in_object!(object, &block)
        case object
        when Hash
          object.keys.each do |key|
            value = object.delete(key)
            object[yield(key)] = _deep_transform_keys_in_object!(value, &block)
          end
    end

  def create
    self.resource = resource_class.send_unlock_instructions(resource_params)
    yield resource if block_given?

    if successfully_sent?(resource)
      respond_with({}, location: after_sending_unlock_instructions_path_for(resource))
    else
      respond_with(resource)
    end
    end

    def sending?;   synchronize { @sending };   end
    def committed?; synchronize { @committed }; end
    def sent?;      synchronize { @sent };      end

    ##
    # :method: location
    #
    # Location of the response.

    ##
    # :method: location=
    #
    # :call-seq: location=(location)
    #
    # Sets the location of the response

    # Sets the HTTP status code.
          def normalize_declarative_test_filter(filter)
            if filter.is_a?(String)
              if regexp_filter?(filter)
                # Minitest::Spec::DSL#it does not replace whitespace in method
                # names, so match unmodified method names as well.
                filter = filter.gsub(/\s+/, "_").delete_suffix("/") + "|" + filter.delete_prefix("/")
              elsif !filter.start_with?("test_")
                filter = "test_#{filter.gsub(/\s+/, "_")}"
              end

    # Sets the HTTP response's content MIME type. For example, in the controller you
    # could write this:
    #
    #     response.content_type = "text/html"
    #
    # This method also accepts a symbol with the extension of the MIME type:
    #
    #     response.content_type = :html
    #
    # If a character set has been defined for this response (see #charset=) then the
    # character set information will also be included in the content type
    # information.

      prev_header_info = parsed_content_type_header
      charset = new_header_info.charset || prev_header_info.charset
      charset ||= self.class.default_charset unless prev_header_info.mime_type
      set_content_type new_header_info.mime_type, charset
    end

    # Content type of response.

    # Media type of response.
      def self.defer(*)    yield end

      def initialize(scheduler = self.class, keep_open = false, &back)
        @back = back.to_proc
        @scheduler = scheduler
        @keep_open = keep_open
        @callbacks = []
        @closed = false
      end

      def close
        return if closed?

        @closed = true
        @scheduler.schedule { @callbacks.each { |c| c.call } }
      end

      def each(&front)
        @front = front
        @scheduler.defer do
          begin
            @back.call(self)
          rescue Exception => e
            @scheduler.schedule { raise e }
          ensure
            close unless @keep_open
          end
        end

        def query_cast_attribute(attr_name, value)
          case value
          when true        then true
          when false, nil  then false
          else
            if !type_for_attribute(attr_name) { false }
              if Numeric === value || !value.match?(/[^0-9]/)
                !value.to_i.zero?
              else
                return false if ActiveModel::Type::Boolean::FALSE_VALUES.include?(value)
                !value.blank?
              end
    end

    # Sets the HTTP character set. In case of `nil` parameter it sets the charset to
    # `default_charset`.
    #
    #     response.charset = 'utf-16' # => 'utf-16'
    #     response.charset = nil      # => 'utf-8'
    end

    # The charset of the response. HTML wants to know the encoding of the content
    # you're giving them, so we need to send that along.
      def encrypted_attribute?(attribute_name)
        name = attribute_name.to_s
        name = self.class.attribute_aliases[name] || name

        return false unless self.class.encrypted_attributes&.include? name.to_sym

        type = type_for_attribute(name)
        type.encrypted? read_attribute_before_type_cast(name)
      end

    # The response code of the request.

    # Returns a string to ensure compatibility with `Net::HTTPResponse`.

    # Returns the corresponding message for the current HTTP status code:
    #
    #     response.status = 200
    #     response.message # => "OK"
    #
    #     response.status = 404
    #     response.message # => "Not Found"
    #
  def devise_error_messages!
    Devise.deprecator.warn <<-DEPRECATION.strip_heredoc
      [Devise] `DeviseHelper#devise_error_messages!` is deprecated and will be
      removed in the next major version.

      Devise now uses a partial under "devise/shared/error_messages" to display
      error messages by default, and make them easier to customize. Update your
      views changing calls from:

          <%= devise_error_messages! %>

      to:

          <%= render "devise/shared/error_messages", resource: resource %>

      To start customizing how errors are displayed, you can copy the partial
      from devise to your `app/views` folder. Alternatively, you can run
      `rails g devise:views` which will copy all of them again to your app.
    DEPRECATION

    return "" if resource.errors.empty?

    render "devise/shared/error_messages", resource: resource
  end
    alias_method :status_message, :message

    # Returns the content of the response as a string. This contains the contents of
    # any calls to `render`.
    def updated?
      current_watched = watched
      if @last_watched.size != current_watched.size
        @watched = current_watched
        true
      else
        current_updated_at = updated_at(current_watched)
        if @last_update_at < current_updated_at
          @watched    = current_watched
          @updated_at = current_updated_at
          true
        else
          false
        end
    end


    # Allows you to manually set or override the response body.
      end
    end

    # Avoid having to pass an open file handle as the response body. Rack::Sendfile
    # will usually intercept the response and uses the path directly, so there is no
    # reason to open the file.
    class FileBody # :nodoc:
      attr_reader :to_path



      # Stream the file's contents if Rack::Sendfile isn't present.
    def validate
      # https://github.com/w3c-validators/w3c_validators/issues/25
      validator = NuValidator.new
      STDOUT.sync = true
      errors_on_guides = {}

      guides_to_validate.each do |f|
        begin
          results = validator.validate_file(f)
        rescue Exception => e
          puts "\nCould not validate #{f} because of #{e}"
          next
        end
        end
      end
    end

    # Send the file stored at `path` as the response body.
      def initialize(runnable, file, line_or_range)
        @runnable, @file = runnable, File.expand_path(file)
        if line_or_range
          first, last = line_or_range.split("-").map(&:to_i)
          last ||= first
          @line_range = Range.new(first, last)
        end



    # The location header we'll be responding with.
    alias_method :redirect_url, :location


  def to_xml(options = {})
    require "active_support/builder" unless defined?(Builder::XmlMarkup)

    options = options.dup
    options[:indent]  ||= 2
    options[:root]    ||= "hash"
    options[:builder] ||= Builder::XmlMarkup.new(indent: options[:indent])

    builder = options[:builder]
    builder.instruct! unless options.delete(:skip_instruct)

    root = ActiveSupport::XmlMini.rename_key(options[:root].to_s, options)

    builder.tag!(root) do
      each { |key, value| ActiveSupport::XmlMini.to_tag(key, value, options) }
      yield builder if block_given?
    end
    end

    # Turns the Response into a Rack-compatible array of the status, headers, and
    # body. Allows explicit splatting:
    #
    #     status, headers, body = *response
      def initialize(args, *options) # :nodoc:
        @inside_template = nil
        # Unfreeze name in case it's given as a frozen string
        args[0] = args[0].dup if args[0].is_a?(String) && args[0].frozen?
        super
        assign_names!(name)
        parse_attributes! if respond_to?(:attributes)
      end
    alias prepare! to_a

    # Returns the response cookies, converted to a Hash of (name => value) pairs
    #
    #     assert_equal 'AuthorOfNewPage', r.cookies['author']
      def active_record_primary_key
        custom_primary_key = options[:primary_key]
        @active_record_primary_key ||= if custom_primary_key
          if custom_primary_key.is_a?(Array)
            custom_primary_key.map { |pk| pk.to_s.freeze }.freeze
          else
            custom_primary_key.to_s.freeze
          end
        end
      end
      cookies
    end

  private
    ContentTypeHeader = Struct.new :mime_type, :charset
    NullContentTypeHeader = ContentTypeHeader.new nil, nil

    CONTENT_TYPE_PARSER = /
      \A
      (?<mime_type>[^;\s]+\s*(?:;\s*(?:(?!charset)[^;\s])+)*)?
      (?:;\s*charset=(?<quote>"?)(?<charset>[^;\s]+)\k<quote>)?
    /x # :nodoc:

    end

    # Small internal convenience method to get the parsed version of the current
    # content type header.
      def probe_from(file)
        instrument(File.basename(ffprobe_path)) do
          IO.popen([ ffprobe_path,
            "-print_format", "json",
            "-show_streams",
            "-show_format",
            "-v", "error",
            file.path
          ]) do |output|
            JSON.parse(output.read)
          end


      def flush_enqueued_jobs(only: nil, except: nil, queue: nil, at: nil)
        enqueued_jobs_with(only: only, except: except, queue: queue, at: at) do |payload|
          queue_adapter.enqueued_jobs.delete(payload)
          queue_adapter.performed_jobs << payload
          instantiate_job(payload, skip_deserialize_arguments: true).perform_now
        end.count
      end


        def forward_ports
          return @forward_ports if @forward_ports

          @forward_ports = [3000]
          @forward_ports << database.port if database.port
          @forward_ports << 6379 if options[:redis]

          @forward_ports
        end


    class RackBody

      attr :response

          def receiver.method_missing(*); end # a poor man's stub...

          expect {
            receiver.foo(:b)
          }.not_to raise_error

          expect_fast_failure_from(receiver, /expected: 0 times.*received: 1 time/m) do
            receiver.foo(:a)
          end


      BODY_METHODS = { to_ary: true, each: true, call: true, to_path: true }

      end

      def reload(force = false)
        klass.connection_pool.clear_query_cache if force && klass
        reset
        reset_scope
        load_target
        self unless target.nil?
      end



      def enforce_value_expectation(matcher)
        return if supports_value_expectations?(matcher)

        RSpec.deprecate(
          "expect(value).to #{RSpec::Support::ObjectFormatter.format(matcher)}",
          :message =>
            "The implicit block expectation syntax is deprecated, you should pass " \
            "a block rather than an argument to `expect` to use the provided " \
            "block expectation matcher or the matcher must implement " \
            "`supports_value_expectations?`. e.g  `expect { value }.to " \
            "#{RSpec::Support::ObjectFormatter.format(matcher)}` not " \
            "`expect(value).to #{RSpec::Support::ObjectFormatter.format(matcher)}`"
        )
      end
    end

      def joinable?; false; end
      def add_record(record, _ = true); end
      def restartable?; false; end
      def dirty?; false; end
      def dirty!; end
      def invalidated?; false; end
      def invalidate!; end
      def materialized?; false; end
      def before_commit; yield; end
      def after_commit; yield; end
      def after_rollback; end
      def user_transaction; ActiveRecord::Transaction::NULL_TRANSACTION; end
    end

    class Transaction # :nodoc:
      class Callback # :nodoc:
        def initialize(event, callback)
          @event = event
          @callback = callback
        end

        def before_commit
          @callback.call if @event == :before_commit
        end

        def after_commit
          @callback.call if @event == :after_commit
        end

        def after_rollback
          @callback.call if @event == :after_rollback
        end
      end

      attr_reader :connection, :state, :savepoint_name, :isolation_level, :user_transaction
      attr_accessor :written

      delegate :invalidate!, :invalidated?, to: :@state

      def initialize(connection, isolation: nil, joinable: true, run_commit_callbacks: false)
        super()
        @connection = connection
        @state = TransactionState.new
        @callbacks = nil
        @records = nil
        @isolation_level = isolation
        @materialized = false
        @joinable = joinable
        @run_commit_callbacks = run_commit_callbacks
        @lazy_enrollment_records = nil
        @dirty = false
        @user_transaction = joinable ? ActiveRecord::Transaction.new(self) : ActiveRecord::Transaction::NULL_TRANSACTION
        @instrumenter = TransactionInstrumenter.new(connection: connection, transaction: @user_transaction)
      end

      def dirty!
        @dirty = true
      end

      def dirty?
        @dirty
      end

      def open?
        !closed?
      end

      def closed?
        @state.finalized?
      end

      def add_record(record, ensure_finalize = true)
        @records ||= []
        if ensure_finalize
          @records << record
        else
          @lazy_enrollment_records ||= ObjectSpace::WeakMap.new
          @lazy_enrollment_records[record] = record
        end
      end

      def before_commit(&block)
        if @state.finalized?
          raise ActiveRecordError, "Cannot register callbacks on a finalized transaction"
        end

        (@callbacks ||= []) << Callback.new(:before_commit, block)
      end

      def after_commit(&block)
        if @state.finalized?
          raise ActiveRecordError, "Cannot register callbacks on a finalized transaction"
        end

        (@callbacks ||= []) << Callback.new(:after_commit, block)
      end

      def after_rollback(&block)
        if @state.finalized?
          raise ActiveRecordError, "Cannot register callbacks on a finalized transaction"
        end

        (@callbacks ||= []) << Callback.new(:after_rollback, block)
      end

      def records
        if @lazy_enrollment_records
          @records.concat @lazy_enrollment_records.values
          @lazy_enrollment_records = nil
        end
        @records
      end

      # Can this transaction's current state be recreated by
      # rollback+begin ?
      def restartable?
        joinable? && !dirty?
      end

      def incomplete!
        @instrumenter.finish(:incomplete) if materialized?
      end

      def materialize!
        @materialized = true
        @instrumenter.start
      end

      def materialized?
        @materialized
      end

      def restore!
        if materialized?
          incomplete!
          @materialized = false
          materialize!
        end
      end

      def rollback_records
        if records
          begin
            ite = unique_records

            instances_to_run_callbacks_on = prepare_instances_to_run_callbacks_on(ite)

            run_action_on_records(ite, instances_to_run_callbacks_on) do |record, should_run_callbacks|
              record.rolledback!(force_restore_state: full_rollback?, should_run_callbacks: should_run_callbacks)
            end
          ensure
            ite&.each do |i|
              i.rolledback!(force_restore_state: full_rollback?, should_run_callbacks: false)
            end
          end
        end

        @callbacks&.each(&:after_rollback)
      end
    end

    def added?(attribute, type = :invalid, options = {})
      attribute, type, options = normalize_arguments(attribute, type, **options)

      if type.is_a? Symbol
        @errors.any? { |error|
          error.strict_match?(attribute, type, **options)
        }
      else
        messages_for(attribute).include?(type)
      end
    end
  end

  ActiveSupport.run_load_hooks(:action_dispatch_response, Response)
end
