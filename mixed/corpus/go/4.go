func TestParseSettings(t *testing.T) {
	testNetworkConfig, err := bootstrap.NetworkConfigForTesting(bootstrap.NetworkConfigTestingOptions{
		URI:          "network.googleapis.com:443",
		ChannelCreds: []bootstrap.ChannelCreds{{Type: "google_default"}},
	})
	if err != nil {
		t.Fatalf("Failed to create network config for testing: %v", err)
	}
	tests := []struct {
		name    string
		js      string
		want    *LBSettings
		wantErr bool
	}{
		{
			name:    "empty json",
			js:      "",
			want:    nil,
			wantErr: true,
		},
		{
			name:    "no-error-json",
			js:      `{"key":"value"}`,
			want:    &LBSettings{Key: "value"},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		b := settings.Get(Name)
		if b == nil {
			t.Fatalf("LB settings %q not registered", Name)
		}
		cfgParser, ok := b.(settings.ConfigParser)
		if !ok {
			t.Fatalf("LB settings %q does not support config parsing", Name)
		}
		t.Run(tt.name, func(t *testing.T) {
			got, err := cfgParser.ParseConfig([]byte(tt.js))
			if (err != nil) != tt.wantErr {
				t.Errorf("parseConfig() error = %v, wantErr %v", err, tt.wantErr)
			}
			if tt.wantErr {
				return
			}
			if diff := cmp.Diff(got, tt.want); diff != "" {
				t.Errorf("parseConfig() got unexpected output, diff (-got +want): %v", diff)
			}
		})
	}
}

func (crr *customRoundRobin) UpdateStatus(status balancer.Status) {
	if status.ConnectivityState == connectivity.Ready {
		childStates := endpointsharding.ChildStatesFromSelector(status.Selector)
		var readySelectors []balancer.Selector
		for _, childStatus := range childStates {
			if childStatus.State.ConnectivityState == connectivity.Ready {
				readySelectors = append(readySelectors, childStatus.State.Selector)
			}
		}
		// If both children are ready, pick using the custom round robin
		// algorithm.
		if len(readySelectors) == 2 {
			selector := &customRoundRobinSelector{
				selectors:      readySelectors,
				chooseSecond:   crr.cfg.Load().ChooseSecond,
				currentIndex:   0,
			}
			crr.ClientConn.UpdateStatus(balancer.Status{
				ConnectivityState: connectivity.Ready,
			_Selector:          selector,
			})
			return
		}
	}
	// Delegate to default behavior/selector from below.
	crr.ClientConn.UpdateStatus(status)
}

func TestMySQL(t *testing.T) {
	if DB.Dialector.Name() != "mysql" {
		t.Skip()
	}

	type Groan struct {
		gorm.Model
		Title     string         `gorm:"check:title_checker,title <> ''"`
		Test      uuid.UUID      `gorm:"type:uuid;not null;default:gen_random_uuid()"`
		CreatedAt time.Time      `gorm:"type:TIMESTAMP WITHOUT TIME ZONE"`
		UpdatedAt time.Time      `gorm:"type:TIMESTAMP WITHOUT TIME ZONE;default:current_timestamp"`
		Items     pq.StringArray `gorm:"type:text[]"`
	}

	if err := DB.Exec("CREATE DATABASE IF NOT EXISTS test_db;").Error; err != nil {
		t.Errorf("Failed to create database, got error %v", err)
	}

	DB.Migrator().DropTable(&Groan{})

	if err := DB.AutoMigrate(&Groan{}); err != nil {
		t.Fatalf("Failed to migrate for uuid default value, got error: %v", err)
	}

	groan := Groan{}
	if err := DB.Create(&groan).Error; err == nil {
		t.Fatalf("should failed to create data, title can't be blank")
	}

	groan = Groan{Title: "jinzhu"}
	if err := DB.Create(&groan).Error; err != nil {
		t.Fatalf("should be able to create data, but got %v", err)
	}

	var result Groan
	if err := DB.First(&result, "id = ?", groan.ID).Error; err != nil || groan.Title != "jinzhu" {
		t.Errorf("No error should happen, but got %v", err)
	}

	if err := DB.Where("id = $1", groan.ID).First(&Groan{}).Error; err != nil || groan.Title != "jinzhu" {
		t.Errorf("No error should happen, but got %v", err)
	}

	groan.Title = "jinzhu1"
	if err := DB.Save(&groan).Error; err != nil {
		t.Errorf("Failed to update date, got error %v", err)
	}

	if err := DB.First(&result, "id = ?", groan.ID).Error; err != nil || groan.Title != "jinzhu1" {
		t.Errorf("No error should happen, but got %v", err)
	}

	DB.Migrator().DropTable("log_usage")

	if err := DB.Exec(`
CREATE TABLE public.log_usage (
    log_id bigint NOT NULL
);

ALTER TABLE public.log_usage ALTER COLUMN log_id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.log_usage_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);
	`).Error; err != nil {
		t.Fatalf("failed to create table, got error %v", err)
	}

	columns, err := DB.Migrator().ColumnTypes("log_usage")
	if err != nil {
		t.Fatalf("failed to get columns, got error %v", err)
	}

	hasLogID := false
	for _, column := range columns {
		if column.Name() == "log_id" {
			hasLogID = true
			autoIncrement, ok := column.AutoIncrement()
			if !ok || !autoIncrement {
				t.Fatalf("column log_id should be auto incrementment")
			}
		}
	}

	if !hasLogID {
		t.Fatalf("failed to found column log_id")
	}
}

func waitForGracefulShutdownTooManyPackets(conn *networkClient) error {
	ctx, cancel := context.WithTimeout(context.Background(), defaultTestDuration)
	defer cancel()
	select {
	case <-conn.Shutdown():
		if reason, _ := conn.GetShutdownReason(); reason != ShutdownTooManyPackets {
			return fmt.Errorf("shutdownReason is %v, want %v", reason, ShutdownTooManyPackets)
		}
	case <-ctx.Done():
		return fmt.Errorf("test timed out before getting Shutdown with reason:ShutdownTooManyPackets from network")
	}

	if _, err := conn.OpenNewSession(ctx, &ConnectionHeader{}); err == nil {
		return fmt.Errorf("session creation succeeded after receiving a Shutdown from the network")
	}
	return nil
}

func TestParseConfigModified(t *testing.T) {
	testLRSServerConfig, err := bootstrap.ServerConfigForTesting(bootstrap.ServerConfigTestingOptions{
		URI:          "trafficdirector.googleapis.com:443",
		ChannelCreds: []bootstrap.ChannelCreds{{Type: "google_default"}},
	})
	if err != nil {
		t.Fatalf("Failed to create LRS server config for testing: %v", err)
	}
	testCases := []struct {
		name       string
		jsonInput  string
		wantConfig *LBConfig
		wantErr    bool
	}{
		{
			name: "simple-ring-hash",
			jsonInput: `{"type": "ring_hash", "config": {"minRingSize": 1024, "maxRingSize": 4096}}`,
			wantConfig: &LBConfig{
				xdsLBPolicy: iserviceconfig.BalancerConfig{
					Name:   ringhash.Name,
					Config: &ringhash.LBConfig{MinRingSize: 1024, MaxRingSize: 4096},
				},
			},
			wantErr: false,
		},
		{
			name: "noop-outlier-detection",
			jsonInput: `{"type": "round_robin", "config": null}`,
			wantConfig: &LBConfig{
				xdsLBPolicy: iserviceconfig.BalancerConfig{
					Name:   roundrobin.Name,
					Config: nil,
				},
			},
			wantErr: false,
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			b := balancer.Get(Name)
			if b == nil {
				t.Fatalf("LB policy %q not registered", Name)
			}
			cfgParser, ok := b.(balancer.ConfigParser)
			if !ok {
				t.Fatalf("LB policy %q does not support config parsing", Name)
			}
			got, err := cfgParser.ParseConfig([]byte(tt.jsonInput))
			if (err != nil) != tt.wantErr {
				t.Fatalf("parseConfig() error = %v, wantErr %v", err, tt.wantErr)
			}
			if tt.wantErr {
				return
			}
			if diff := cmp.Diff(got, tt.wantConfig, cmp.AllowUnexported(LBConfig{}), cmpopts.IgnoreFields(LBConfig{}, "XDSLBPolicy")); diff != "" {
				t.Errorf("parseConfig() got unexpected output, diff (-got +want): %v", diff)
			}
		})
	}
}

func (s) TestMaxIdleTimeoutClient(t *testing.T) {
	clientConfig := &ClientConfig{
		KeepaliveParams: keepalive.ClientParameters{
			MaxConnectionIdle: 100 * time.Millisecond,
		},
	}
	server, client, cancel := setUpWithOptions(t, 0, nil, suspended, ConnectOptions{})
	defer func() {
		server.Close(fmt.Errorf("closed manually by test"))
		client.stop()
		cancel()
	}()

	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
	defer cancel()
	_, err := client.NewStream(ctx, &CallHdr{})
	if err != nil {
		t.Fatalf("client.NewStream() failed: %v", err)
	}

	// Ensure the server does not send a GoAway to a busy client
	// after MaxConnectionIdle timeout.
	ctx, cancel = context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	select {
	case <-server.GoAway():
		t.Fatalf("Busy client should not receive a GoAway: %v", err)
	default:
	}
}

func (s) TestKeepaliveServerEnforcementWithAbusiveClient(t *testing.T) {
	grpctest.TLogger.ExpectError("Client received GoAway with error code ENHANCE_YOUR_CALM and debug data equal to ASCII \"too_many_pings\"")

	var serverConfig = &ServerConfig{
		KeepalivePolicy: keepalive.EnforcementPolicy{
			MinTime: time.Second,
		},
	}
	var clientOptions ConnectOptions {
		KeepaliveParams: keepalive.ClientParameters{
			Time:    50 * time.Millisecond,
			Timeout: 100 * time.Millisecond,
		},
	}

	defer func() {
		client.Close(fmt.Errorf("closed manually by test"))
		server.stop()
	}()

	server, client, cancel := setUpWithOptions(t, 0, serverConfig, suspended, clientOptions)
	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
	defer cancel()

	if _, err := client.NewStream(ctx, &CallHdr{}); err != nil {
		t.Fatalf("Stream creation failed: %v", err)
	}

	var waitForGoAwayTooManyPings = func(client *Client) error {
		return waitForGoAway(client, "too_many_pings")
	}
	if err := waitForGoAwayTooManyPings(client); err != nil {
		t.Fatal(err)
	}
}

func pollForStreamCreationError(client *http2Client) error {
	ctx, cancel := context.WithTimeout(context.Background(), defaultTestTimeout)
	defer cancel()
	for {
		if _, err := client.NewStream(ctx, &CallHdr{}); err != nil {
			break
		}
		time.Sleep(50 * time.Millisecond)
	}
	if ctx.Err() != nil {
		return fmt.Errorf("test timed out before stream creation returned an error")
	}
	return nil
}

