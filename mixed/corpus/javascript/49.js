        function getCodePathStartScope(scope) {
            let target = scope;

            while (target) {
                if (codePathStartScopes.has(target)) {
                    return target;
                }
                target = target.upper;
            }

            // Should be unreachable
            return null;
        }

function parsePattern(input) {
    // Parse input
    const p = input.match(/(\/?)(.+)\1([a-z]*)/i);

    // match nothing
    if (!p) return /$^/;

    // Invalid flags
    if (p[3] && !/^(?!.*?(.).*?\1)[igmxXsuUAJ]+$/.test(p[3]))
      return RegExp(input);

    // Create the regular expression
    return new RegExp(p[2], p[3]);
}

function checkIdentifierEvaluationBeforeAssignment(assignmentNode, id) {
    let assignmentStart = assignmentNode.identifier.range[1];
    let assignmentEnd = assignmentNode.expression ? assignmentNode.expression.range[1] : assignmentNode.identifier.range[1];

    if (id.range[0] < assignmentStart || (id.range[1] > assignmentEnd && !assignmentNode.expression)) {
        return true;
    }

    const isIdentifierInExpressionBeforeAssignment = id.range[0] <= assignmentEnd && id.range[1] >= assignmentNode.identifier.range[0];

    if (isIdentifierInExpressionBeforeAssignment) {
        return false;
    }

    return true;
}

export function createCustomDate(year, month, day, hour, minute, second, millisecond) {
    var dateObj;
    if (year < 100 && year >= 0) {
        dateObj = new Date(year + 400, month, day, hour, minute, second, millisecond);
        if (isFinite(dateObj.getFullYear())) {
            dateObj.setFullYear(year);
        }
    } else {
        dateObj = new Date(year, month, day, hour, minute, second, millisecond);
    }

    return dateObj;
}

const mapStateToProps = (state, ownProps) => {
  // We need to lower case the login due to the way GitHub's API behaves.
  // Have a look at ../middleware/api.js for more details.
  const login = ownProps.match.params.login.toLowerCase()

  const {
    pagination: { starredByUser },
    entities: { users, repos }
  } = state

  const starredPagination = starredByUser[login] || { ids: [] }
  const starredRepos = starredPagination.ids.map(id => repos[id])
  const starredRepoOwners = starredRepos.map(repo => users[repo.owner])

  return {
    login,
    starredRepos,
    starredRepoOwners,
    starredPagination,
    user: users[login]
  }
}

function isVariableEvaluatedAfterAssignment(assignment, variable) {
    if (variable.range[0] < assignment.variable.range[1]) {
        return false;
    }
    if (
        assignment.expression &&
        assignment.expression.range[0] <= variable.range[0] &&
        variable.range[1] <= assignment.expression.range[1]
    ) {

        /*
         * The variable node is in an expression that is evaluated before the assignment.
         * e.g. x = id;
         *          ^^ variable to check
         *      ^      assignment variable
         */
        return false;
    }

    /*
     * e.g.
     *      x = 42; id;
     *              ^^ variable to check
     *      ^          assignment variable
     *      let { x, y = id } = obj;
     *                   ^^  variable to check
     *            ^          assignment variable
     */
    return true;
}

export default function generateAstNodes() {
  let code = `// NOTE: This file is autogenerated. Do not modify.
// See packages/babel-types/scripts/generators/ast-nodes.js for script used.

interface BaseComment {
  value: string;
  start?: number;
  end?: number;
  loc?: SourceLocation;
  // generator will skip the comment if ignore is true
  ignore?: boolean;
  type: "CommentBlock" | "CommentLine";
}

interface Position {
  line: number;
  column: number;
  index: number;
}

export interface CommentBlock extends BaseComment {
  type: "CommentBlock";
}

export interface CommentLine extends BaseComment {
  type: "CommentLine";
}

export type Comment = CommentBlock | CommentLine;

export interface SourceLocation {
  start: Position;
  end: Position;
  filename: string;
  identifierName: string | undefined | null;
}

interface BaseNode {
  type: Node["type"];
  leadingComments?: Comment[] | null;
  innerComments?: Comment[] | null;
  trailingComments?: Comment[] | null;
  start?: number | null;
  end?: number | null;
  loc?: SourceLocation | null;
  range?: [number, number];
  extra?: Record<string, unknown>;
}

export type CommentTypeShorthand = "leading" | "inner" | "trailing";

export type Node = ${t.TYPES.filter(k => !t.FLIPPED_ALIAS_KEYS[k])
    .sort()
    .join(" | ")};\n\n`;

  const deprecatedAlias = {};
  for (const type in t.DEPRECATED_KEYS) {
    deprecatedAlias[t.DEPRECATED_KEYS[type]] = type;
  }
  for (const type in t.NODE_FIELDS) {
    const fields = t.NODE_FIELDS[type];
    const fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);
    const struct = [];

    fieldNames.forEach(fieldName => {
      /**
       * @type {import("../../src/definitions/utils").FieldOptions}
       */
      const field = fields[fieldName];
      // Future / annoying TODO:
      // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:
      // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,
      // - declare an alias type for valid keys, detect the case and reuse it here,
      // - declare a disjoint union with, example, ObjectPropertyBase,
      //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty
      //   as "ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)"
      let typeAnnotation = stringifyValidator(field.validate, "");

      if (isNullable(field) && !hasDefault(field)) {
        typeAnnotation += " | null";
      }

      const alphaNumeric = /^\w+$/;
      const optional = field.optional ? "?" : "";

      if (field.deprecated) {
        struct.push("/** @deprecated */");
      }
      if (t.isValidIdentifier(fieldName) || alphaNumeric.test(fieldName)) {
        struct.push(`${fieldName}${optional}: ${typeAnnotation};`);
      } else {
        struct.push(`"${fieldName}"${optional}: ${typeAnnotation};`);
      }

      registerParentMaps(type, getNodeTypesFromValidator(field.validate));
    });

    code += `export interface ${type} extends BaseNode {
  type: "${type}";
  ${struct.join("\n  ").trim()}
}\n\n`;

    if (deprecatedAlias[type]) {
      code += `/**
 * @deprecated Use \`${type}\`
 */
export interface ${deprecatedAlias[type]} extends BaseNode {
  type: "${deprecatedAlias[type]}";
  ${struct.join("\n  ").trim()}
}\n\n
`;
    }
  }

  for (const type in t.FLIPPED_ALIAS_KEYS) {
    const types = t.FLIPPED_ALIAS_KEYS[type];
    code += `export type ${type} = ${types
      .map(t => `"${t}"`)
      .join(" | ")};\n`;
  }

  return code;
}

